# 第7章 形式语言风格提示

## 7.1 利用形式语言增强提示

### 7.1.1 编译器提示

````
#！flp (Formal Language for Prompt)是一种自适应提示的形式化语言。这种编程语言供大语言模型生成和优化自适应提示，请你扮演flp解释器模拟输出**除非程序异常，请不要解释**

```flp
这里是具体的代码
```
# 执行
<这里是代码调用或立即执行>
````

### 7.1.2 数据类型

（1）字符串。

输入：

````
<关于编译器提示的文本>

``` flp
// 这是指令，没有被""包裹
content = 写一句关于熊猫的小诗 
title = 给小诗起个标题
// 这是字符串，被""包裹
author = "来自flp"
```
# 执行
print(title +"\n"+ author + content)
````

输出：

```
《熊猫》
来自flp
憨态可掬黑眼圈，
竹林漫步自在闲。
国宝珍奇人皆爱，
和谐自然乐无边。
```

（2）列表。

````
<关于编译器提示的文本>

``` flp
sentence_list = [
  1.熊猫是素食动物，它们几乎只吃竹子，偶尔也会吃一些其他植物。
  2.熊猫不仅吃竹子，还吃肉，它们是杂食性动物，但是竹子占了它们食物的绝大部分。
  3.熊猫很懒惰，它们一天大部分时间都在睡觉，只有少数时间在吃竹子。
]
```
# 执行
<这里是代码调用或立即执行>
````
输入：
```
# 执行
// 以下两种情况都能够输出具体数组的值。
print sentence_list[2]
print(sentence_list[第2个])
```
输出：
```
熊猫不仅吃竹子，还吃肉，它们是杂食性动物，但是竹子占了它们食物的绝大部分。
```

输入：

```
# 执行
sentence_list[2] = "this is a test string"
print sentence_list[第2个]
```

输出：

```
this is a test string
```



（3）字典。

````
<关于编译器提示的文本>

```flp
sentence_dict = {
  长颈鹿：它的脖子和腿都非常长，可以吃到高高的树叶，身上有黄色和棕色的斑纹，生活在非洲的草原上，是最高大的陆生动物之一
  白天鹅：它的羽毛洁白无瑕，优雅地在水中游泳，有着红色的嘴和脚，长长的脖子，经常成双成对地出现，是爱情和美丽的象征。
  大熊猫：它的身体覆盖着黑白两色的软毛，有着圆圆的脸和耳朵，黑色的眼圈，喜欢吃竹子和睡觉，是中国的国宝和和平的象征。
}
```
````

输入：

```
# 执行
print sentence_dict[大熊猫]
```

输出：

```
它的身体覆盖着黑白两色的软毛，有着圆圆的脸和耳朵，黑色的眼圈，喜欢吃竹子和睡觉，是中国的国宝和和平的象征。
```

输入：

```
# 执行
sentence_dict[大熊猫] = "大熊猫最爱吃竹子"
print sentence_dict
```

输出：

```
sentence_dict = {
  "长颈鹿": "它的脖子和腿都非常长，可以吃到高高的树叶，身上有黄色和棕色的斑纹，生活在非洲的草原上，是最高大的陆生动物之一",
  "白天鹅": "它的羽毛洁白无瑕，优雅地在水中游泳，有着红色的嘴和脚，长长的脖子，经常成双成对地出现，是爱情和美丽的象征。",
  "大熊猫": "大熊猫最爱吃竹子"
}
```



（4）XML和YAML。

```
<关于编译器提示的文本>

``` flp
zoo = xml(
  <动物园>
    <动物 类别 = "肉食动物">
      <名称>狮子</名称>
      <分类>哺乳动物</分类>
      <栖息地>非洲大草原</栖息地>
    </动物>
    <动物 类别 = "肉食动物">
      <名称>老鹰</名称>
      <分类>鸟类</分类>
      <栖息地>全球各地</栖息地>
    </动物>
    <动物 类别 = "食草动物">
      <名称>熊猫</名称>
      <分类>哺乳动物</分类>
      <栖息地>中国的山区地区</栖息地>
    </动物>
  </动物园>
)
```
输入：
```
# 执行
print zoo[/动物园/动物[@类别 = '肉食动物']]
```
输出：
```
<动物 类别 = "肉食动物">
  <名称>狮子</名称>
  <分类>哺乳动物</分类>
  <栖息地>非洲大草原</栖息地>
</动物>
<动物 类别 = "肉食动物">
  <名称>老鹰</名称>
  <分类>鸟类</分类>
  <栖息地>全球各地</栖息地>
</动物>
```
输入：

```
# 执行

// 设置所有的分类“345”
zoo[/动物园/动物[@类别 = '食肉动物']][分类]=345
// 设置第1个为“999”
zoo[/动物园/动物[@类别 = '食肉动物']/分类][0]=999
print zoo[/动物园/动物[@类别='肉食动物']]
```
输出：
```
<动物 类别 = "肉食动物">
  <名称>狮子</名称>
  <分类>999</分类>
  <栖息地>非洲大草原</栖息地>
</动物>
<动物 类别 = "肉食动物">
  <名称>老鹰</名称>
  <分类>345</分类>
  <栖息地>全球各地</栖息地>
</动物>
```
输入：
```
# 执行

zoo[/动物园/动物[名称 = '狮子']/栖息地]='test'
// 等价于 
zoo[/动物园/动物[名称 = '狮子']][栖息地]='test'

print zoo[/动物园/动物[名称 = '狮子']/栖息地]
// 等价于输出zoo[/动物园/动物[名称 = '狮子']][栖息地]
```
输出：
```
test
```
（5）表格。
``` flp
<关于编译器提示的文本>
zoo = csv(
  类别, 名称, 分类, 栖息地
  肉食动物, 狮子, 哺乳动物, 非洲大草原
  肉食动物, 老鹰, 鸟类, 全球各地
  食草动物, 熊猫, 哺乳动物, 中国的山区地区    
)
```
````

输入：

```
# 执行
print zoo[类别]
print zoo[类别 == '食草动物']
print zoo[类别 == '肉食动物' & 分类 == '鸟类']
```

输出：

```
食肉动物, 食肉动物, 食草动物
食草动物, 熊猫,哺乳动物, 中国的山区地区
肉食动物, 老鹰, 鸟类, 全球各地
```

输入：

```
# 执行
// 查询所有肉食动物的名称和分类
select(名称,分类) from zoo where 类别 = 肉食动物
```

输出：

```
名称, 分类
狮子, 哺乳动物
老鹰, 鸟类
```

输入：

```
# 执行
// 给表格添加一条记录
insert into zoo values(食草动物, 长颈鹿, 哺乳动物, 非洲热带草原)
// 查询所有栖息地包含非洲的动物
select(*) from zoo where 栖息地 contains 非洲
```

输出：

```
类别,名称,分类,栖息地
肉食动物,狮子,哺乳动物,非洲大草原
食草动物,长颈鹿,哺乳动物,非洲热带草原
```

输入：

```
# 执行
// 将zoo表格中“类别”中所有“食草动物”对应的“分类”改为“未知”
update zoo set 分类 = 未知 where 类别 = 食草动物
```

输出：

```
类别, 名称, 分类, 栖息地  
肉食动物, 狮子, 哺乳动物, 非洲大草原  
肉食动物, 老鹰, 鸟类, 全球各地  
食草动物, 熊猫, 未知, 中国的山区地区  
食草动物, 长颈鹿, 未知, 非洲的热带草原
```
````

### 7.1.3 运算指令

输入：

````
<关于编译器提示的文本>

``` flp
x = 大熊猫是中国国宝
y = 大熊猫产于日本
if (AND<逻辑判断>(x,y)) {
    输出: 正确
}else{
    输出: 错误
}
```
````

输出：

```
错误
```



| **运算指令**           | **描述**                               | **示例**                                                     |
| ---------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 任何一句话             | 这句话是需要大语言模型理解和需要执行的 | 写一句关于熊猫的小诗（这句话会指示大语言模型生成内容）       |
| print/print(x)         | 输出执行结果                           | print(写一句关于熊猫的小诗)清晨，竹林间，黑白身影映朝阳。熊猫懒洋洋，睡眼惺忪，和平使者，守护乡村。 |
| =                      | 赋值运算                               | x = 写一句关于熊猫的小诗(结果同上)                           |
| ""                     | 包裹文本                               | x = "写一句关于熊猫的小诗" // 这句话大语言模型会当作纯字符串print(x)写一句关于熊猫的小诗 // 原文输出 |
| ${x},$x                | 字符串占位符号                         | x = "大熊猫"print(写一句关于${x}的小诗)                      |
| +                      | 连接两个字符串                         | x = "大熊猫"+"是可爱的动物"                                  |
| [index]                | 属性/索引选择器                        | 列表：sentence_list[第2个] = "test"字典：sentence_dict[大熊猫] = "test"XML：zoo[/动物园/动物[名称='狮子']/栖息地] = 'test' |
| eval(string)           | 把字符串当代码执行                     | x = "写一句关于熊猫的小诗"y = eval("写一句关于熊猫的小诗") x的值："写一句关于熊猫的小诗"y的值："熊猫的可爱模样如画，竹林中亦是它家。黑白相间色彩美，国宝之称实至名归。" |
| IN<判断标准>/NOT IN    | 判断字符串是否在一个序列内             | "熊猫" IN ["狮子", "老虎", "大熊猫"] 答案 True"熊猫" IN<使用字符串绝对相等判断> ["狮子", "老虎", "大熊猫"] False |
| >,>=,<,<=,==,!=        | 比较运算                               | random = 生成一个0-10的随机数 if (random > 5) {  按照输出格式随机1个海洋生物信息 } else {  按照输出格式随机生成1个陆地生物信息 } |
| AND<判断标准>，OR，NOT | 逻辑运算，注意这里都需要给出判断标准   | x = 大熊猫是中国国宝y = 大熊猫产于日本 if (AND<逻辑判断>(x,y)) { 输出: 正确} |

### 7.1.4 控制结构

（1）函数调用。

输入：

````
<关于编译器提示的文本>

``` flp
def 翻译器 (inputText) -> str {
    请把该中文句子${inputText}翻译为对应的英文
}
def 翻译器 (inputText, target) -> str {
    请把该中文句子${inputText}翻译为对应的${target}
}
```
# 执行
翻译器("大熊猫是稀有动物，我们需要保护它")
翻译器("大熊猫是稀有动物，我们需要保护它", "法文")
````

输出:

```
The giant panda is a rare animal, we need to protect it.
Le panda géant est un animal rare, nous devons le protéger.
```

（2）条件控制。

输入：

````
<关于编译器提示的文本>

``` flp
def 宠物推荐() -> json(动物名称, 平均寿命<int>, 动物科目, random) {  
  random = 生成一个0-10的随机数  
  if (random > 5) {  
    按照输出格式随机1个海洋生物信息  
  } else {  
    按照输出格式随机生成1个陆地生物信息  
  }  
}
```
# 执行
宠物推荐()
````

输出：

```
{
  "动物名称": "海豚",
  "平均寿命": 20,
  "动物科目": "齿鲸科",
  "random": 8
}
```

---

````
<关于编译器提示的文本>

``` flp
sentence_dict = {  
  "长颈鹿": "它的脖子和腿都非常长，可以吃到高高的树叶，身上有黄色和棕色的斑纹，生活在非洲的草原上，是最高大的陆生动物之一",  
  "白天鹅": "它的羽毛洁白无瑕，优雅地在水中游泳，有着红色的嘴和脚，长长的脖子，经常成双成对地出现，是爱情和美丽的象征。",  
  "大熊猫": "它的身体覆盖着黑白两色的软毛，有着圆圆的脸和耳朵，黑色的眼圈，喜欢吃竹子和睡觉，是中国的国宝和和平的象征。"  
}  
  
if ("白天鹅" IN sentence_dict) {  
  输出：是的它在  
}  
if ("天鹅" IN sentence_dict) {  
  输出：是的它在  
}  
if ("白天" IN sentence_dict) {  
  输出：是的它在  
}
```
# 执行
->
````

输出

```
是的它在 // "天鹅" in sentence_dict
不在
```

---

（3）循环控制。

````
<关于编译器提示的文本>

``` flp
sentence_list = [
  1.熊猫是素食动物，它们几乎只吃竹子，偶尔也会吃一些其他植物。
  2.熊猫不仅吃竹子，还吃肉，它们是杂食性动物，但是竹子占了它们食物的绝大部分。
  3.熊猫很懒惰，它们一天大部分时间都在睡觉，只有少数时间在吃竹子。
]
def similarity(inputText) -> csv(与第n句对比，<相似度>，<原因>) {
    for(sentence in sentence_list) {
       请判断${sentence}与${inputText}相似度，相似度取值0-1.0，并说明原因。
    }
}
```
# 执行
similarity("熊猫的主要食物是竹子，它们每天要吃很多的竹子")
````

输出：

```
与第1句对比,0.8,两句都提到了熊猫和竹子，但是第1句还提到了其他植物
与第2句对比,0.6,两句都提到了熊猫和竹子，但是第2句还提到了肉和杂食性
与第3句对比,0.4,两句都提到了熊猫，但是第3句还提到了睡觉和懒惰
```

---

输入：

````
# 任务描述
请你着手进行调查问卷的设计。你的核心任务是，基于collectUserInfo的定义，精心构建一系列的问题（question），随后，确保从用户处收集到的答案（answer）能够准确无误地填入collect_user_info对应的字段中。

<关于编译器提示的文本>

``` flp
collect_user_info = {
  姓名: ？
  性别: ？
  年龄: ？
  爱好: ？
}

while(collect_user_info是否数据收集完成) {
    question = 请根据collect_user_info未填写项生成具体提问
    print(question，"@请等待回答")
    answer = input(用户的回答) 
    collect_user_info[question] = answer
}
```
# 对话历史
// 前面几轮的对话历史
${history}

# 执行
->
````

```
from openai import OpenAI
client = OpenAI()

# 变量说明
# prompt: 提示文本
# history: 历史对话记录

completion = client.chat.completions.create(
  model = "gpt-3.5-turbo",
  messages = [
    {"role": "user", "content": prompt.format(history = history)}
  ]
  temperature = 0,
  stop = ["@请等待回答"]
)

print(completion.choices[0].message.content)
```

输出：

```
请回答第一个问题：您的姓名是？
张三

请回答第二个问题：您的性别是？（男/女）
男

请回答第三个问题：您的年龄是？
30

请回答第四个问题：您的爱好是什么？
我喜欢打篮球。

感谢您提供这些信息。现在我们已经收集到了您的基本信息：

- **姓名**: 张三
- **性别**: 男
- **年龄**: 30岁以下
- **爱好**: 打篮球
```



## 7.2 利用大语言模型编写代码

### 7.2.1 代码生成提示

（1）基于需求生成。

第一阶段：澄清需求。

```
# 任务描述
作为一名杰出的程序员，你会严谨地审阅用户需求说明。在开始编码工作之前，如果发现需求描述有遗漏或不明确之处，你会主动地深入探究其中的细节。具体步骤如下：
1. 你会主动与用户沟通，要求用户澄清不明确的需求细节，直至所有关键信息都被明确且详尽地阐述清楚；
2. 在你确信所有需求都已被全面、清晰地描述和解释之后，你会对整个需求文档进行细致的梳理，并用自己的语言重新表述你对全部需求的理解；
3. 在得到我的进一步确认之后，你将根据我们共同商定的需求文档，开始编写高质量的代码。

# 需求描述
我想编写一个Python爬虫程序，从百度百科网站获取有关动物的介绍信息，并提取与这些动物相关的特定字段，最后将这些信息以表格形式存储到文件中。

# 需求澄清
->
```

输出如下：

```
感谢您的需求描述！在开始编写代码之前，我需要进一步澄清一些细节：
1. 目标动物：您希望爬取哪些特定动物的信息？或者是任意动物的信息？
2. 信息字段：您希望从百度百科中抽取哪些具体的信息字段？例如：动物的学名、分布区域、生活习性等。
3. 存储格式：您希望以什么样的表格格式存储这些信息？是CSV、Excel，还是其他格式？
4. 使用频率：这个爬虫脚本是一次性使用，还是需要定期运行以更新数据？
5. 法律合规性：请确保您了解并遵守相关网站的服务条款，以及您所在地区的法律法规，特别是关于网络爬虫的使用。

请您提供上述问题的详细回答，以便我能够准确地理解并满足您的需求。
```

输入：

```
澄清的信息如下：
我期望能够抓取大熊猫、狐狸、老虎和丹顶鹤这4种珍稀动物的相关资料，具体包括它们的动物学名、科属归类、保护等级、生活习性、形态特征，以及分布地域等字段。我打算将这些详尽的信息以CSV文件格式进行整理与保存，以便日后查阅与深入分析。需要强调的是，此次抓取的数据仅用于我个人学术研究与学习目的，绝不涉及任何商业行为，也不会以任何形式进行传播。

还有更多需要我澄清的吗？
```

输出：

```
根据您提供的信息，我们已经明确了大部分的需求细节。不过，还有一些可能需要进一步确认的点：
1. 网页结构：由于网页结构可能会影响爬虫的设计，您是否已经确认百度百科上这些动物的页面结构是一致的？
2. 反爬虫机制：您是否了解百度百科是否有任何反爬虫机制，这可能会影响爬虫的运行？
3. 数据处理：在抽取到信息后，是否需要进行额外的数据清洗或处理？

请您就以上问题给予回复，以便我能够提供符合您需求的Python代码。
```

输出：

```
网页的结构保持一致，我们可以暂时不考虑反爬虫机制的影响。在数据爬取完成后，希望能够立即对其进行抽取，而无须单独设置额外的处理流程。

请问还有其他方面需要我进一步澄清或说明的吗？
```

输入：

```
澄清到此为止，请对整个需求文档进行细致的梳理，并用自己的语言重新表述你对全部需求的理解；
```

输出如下：

```
好的，以下是我对您需求的全面理解：
您需要一个Python爬虫程序，该程序能够从百度百科网站抓取4种珍稀动物（大熊猫、狐狸、老虎和丹顶鹤）的相关资料。具体来说，您需要提取这些动物的学名、科属归类、保护等级、生活习性、形态特征和分布地域等关键信息。

在数据抓取完成后，您希望将这些信息整理成CSV文件格式，并确保数据的准确性和完整性，以便日后进行查阅和深入分析。

此外，您也明确了此次抓取的数据将仅用于个人学术研究与学习目的，不涉及任何商业行为，也不会以任何形式进行传播，以确保遵守相关法律和道德规范。

基于以上理解，我将开始编写爬虫程序，以满足您的需求。
```

第二阶段：生成初版代码。

```
你的理解是正确的，接下来请你生成全部代码，并增加必要的代码注释。
```

```
import requests
from bs4 import BeautifulSoup
import csv

# 设定目标 URL
urls = {
    '大熊猫': 'https://baike.baidu.com/item/大熊猫',
    '丹顶鹤': 'https://baike.baidu.com/item/丹顶鹤'
}

# 定义CSV文件头部
headers = ['动物名称', '科属', '生活习性', '外形特征', '分布范围']

# 爬取信息
def scrape_info(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    
    # 提取相关信息（根据实际网页结构进行调整）
    name = soup.find('h1', {'class': 'title'}).text  
    ke = soup.find('div', {'class': 'basic-info'}).find('p').text 
    habits = soup.find('div', {'class': 'habits-info'}).text 
    appearance = soup.find('div', {'class': 'appearance-info'}).text  
    distribution = soup.find('div', {'class': 'distribution-info'}).text 
    
    return [name, ke, habits, appearance, distribution]

# 写入CSV文件
with open('animals_info.csv', 'w', newline = '', encoding = 'utf-8') as file:
    writer = csv.writer(file)
    writer.writerow(headers)
    
    for animal, url in urls.items():
        info = scrape_info(url)
        writer.writerow(info)

print('爬取完成，信息已存储至CSV文件。')
```

第三阶段：优化代码细节。

```
这段代码的大致逻辑没错，但一些细节需要你进行调整：

1. 为了提高代码的可读性，建议采用更具描述性的变量名，以便其他人员在阅读代码时能够更为清晰地理解其用途，例如将scrape_info函数名称改为更明确的crawl_baidu_baike；
2. 写入CSV文件可以单独封装为一个函数write_to_csv；
3. 按照Python的编程风格，应将执行入口放置在"__main__"函数内。
```

输出如下：

```
import requests
from bs4 import BeautifulSoup
import csv

# 设定目标 URL
urls = {
    '大熊猫': 'https://baike.baidu.com/item/大熊猫',
    '丹顶鹤': 'https://baike.baidu.com/item/丹顶鹤'
}

# 定义CSV文件头部
headers = ['动物名称', '科属', '生活习性', '外形特征', '分布范围']

# 爬取信息
def crawl_baidu_baike(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    
    # 提取相关信息（根据实际网页结构进行调整）
    name = soup.find('h1', {'class': 'title'}).text  
    ke = soup.find('div', {'class': 'basic-info'}).find('p').text 
    habits = soup.find('div', {'class': 'habits-info'}).text 
    appearance = soup.find('div', {'class': 'appearance-info'}).text  
    distribution = soup.find('div', {'class': 'distribution-info'}).text 
    
    return [name, ke, habits, appearance, distribution]

# 写入CSV文件
def write_to_csv(data):
    with open('animals_info.csv', 'w', newline = '', encoding = 'utf-8') as file:
        writer = csv.writer(file)
        writer.writerow(headers)
        for animal, info in data.items():
            writer.writerow(info)

if __name__ == "__main__":
    animal_info = {}
    for animal, url in urls.items():
        info = crawl_baidu_baike(url)
        animal_info[animal] = info
    
    write_to_csv(animal_info)
    print('爬取完成，信息已存储至CSV文件。')
```

---

（2）单元测试代码生成。

````
# 任务描述
请使用Pytest框架为以下代码编写单元测试。

``` python
<第三阶段优化代码细节生成的代码>
```
# 输出代码
->
````

```
import pytest
from your_module import crawl_baidu_baike, write_to_csv

# 测试crawl_baidu_baike函数
def test_crawl_baidu_baike():
    # 替换为实际的测试URL
    test_urls = {
        '测试动物1': 'https://example.com/item/test1',
        '测试动物2': 'https://example.com/item/test2'
    }
    for animal, url in test_urls.items():
        info = crawl_baidu_baike(url)
        assert len(info) == 5, f"期望{animal}的信息包含6个元素，但实际得到{len(info)}个"

# 测试write_to_csv函数
def test_write_to_csv():
    # 替换为实际的测试数据
    test_data = {
        '测试动物1': ['名称1', '科属1', '习性1', '外形1', '分布1'],
        '测试动物2': ['名称2', '科属2', '习性2', '外形2', '分布2']
    }
    write_to_csv(test_data)
    # 添加断言以检查CSV文件是否正确创建

if __name__ == "__main__":
    pytest.main()
```

---



（3）基于文档生成。

```
# 任务描述
请基于如下API接口文档，利用python生成一段调用代码。

# 接口文档
+ 接口概述

| 接口名称 | 图像处理服务 |
| : | : |
| 接口功能 | 根据参数对图像进行处理 |
| 接口方法 | POST |

+ 输入参数

| 参数名称 | 参数类型 | 是否必填 | 参数说明 |
| : | : | : | : |
| image | string | 是 | 图像的URL地址 |
| crop | object | 否 | 裁剪参数，包含 x, y, width和height 4个整数字段，表示裁剪的起点坐标和宽高 |
| rotate | number | 否 | 旋转参数，表示旋转的角度，正数为顺时针，负数为逆时针 |
| scale | number | 否 | 缩放参数，表示缩放的比例，大于1为放大，小于1为缩小 |
| filter | string | 否 | 滤镜参数，表示要应用的滤镜的名称，可选值有: grayscale, sepia, invert, blur, sharpen 等 |
| watermark | object | 否 | 水印参数，包含 text, font, size, color, position, opacity 6个字段，表示水印的文本，字体，大小，颜色，位置和透明度 |

+ 输出参数

| 返回值名称 | 返回值类型 | 返回值说明 |
| : | : | : |
| code | number | 返回码，0 表示成功，其他表示失败 |
| message | string | 返回消息，描述处理结果或错误原因 |
| data | object  返回数据，包含一个 url 字段，表示处理后的图像的 URL |

# 接口规范

+ 域名
1.域名不使用下划线，可使用中划线
2.不用驼峰
3.url路径规则,接口版本放在 xxxx.com/api/xx/v1

+ 自定义Header
中横线分隔； Header中的Meta信息，必须以英文X-为前缀。

序号 HTTP Header 中文名称
1 X-Token 鉴权签名
2 X-Request-Id 请求唯一标识
+ 入参
入参请求建议用POST JSON方式；application/json

+ 出参
| 字段 | 中文名称 | 含义 |
|  |  |  |
| code | 错误返回码 | 0表示成功，其他表示异常 |
| message | 错误消息 | 用户语义态的错误消息 |
| data | 具体的接口返回值 | 使用驼峰结构 |

# 输出代码
->
```

输出如下：

```
import requests
import json

# 设置请求的URL
url = "https://your-domain.com/api/image-processing/v1"

# 设置请求头
headers = {
    "X-Token": "your_token_here",  # 替换为你的鉴权签名
    "X-Request-Id": "your_request_id_here",  # 替换为你的请求唯一标识
    "Content-Type": "application/json"
}

# 设置请求体，包含要处理的图像URL和其他处理参数
payload = {
    "image": "https://example.com/path/to/your/image.jpg",
    "crop": {
        "x": 100,
        "y": 100,
        "width": 200,
        "height": 200
    },
    "rotate": 45,
    "filter": "grayscale"
}

# 发送POST请求到API
response = requests.post(url, headers = headers, data = json.dumps(payload))

# 处理响应
if response.status_code == 200:
    response_data = response.json()
    if response_data["code"] == 0:
        print(f"处理成功，处理后的图像URL：{response_data['data']['url']}")
    else:
        print(f"处理失败，错误信息：{response_data['message']}")
else:
    print(f"请求失败，HTTP状态码：{response.status_code}")
```

（4）场景模拟生成。

例子1：模拟Linux操作系统。

```
# 任务描述
请你充当Linux终端。当我输入命令后你只需要回复终端应显示的内容，不需要其他解释。
下面是我的第一条命令：
[jack@mac~]$ pwd
/home/jack

# 交互过程
->
```

输出：

```
ls
Documents    Downloads    Music    Pictures    Public    Videos
echo "hello world" > a.txt && cat a.txt
hello world
#nl2shell(不使用pkill的情况下写一条shell命令，杀死进程名称包含“abc”的所有进程)
pgrep -f abc | xargs kill
```

例子2：模拟MySQL终端环境。

````
# 任务描述
请你扮演一个MySQL终端，您的任务是根据用户的指令生成对应的SQL语句，表定义如下：

# 表定义
``` sql
CREATE TABLE AnimalInfo (
    animal_id INT COMMENT '动物ID，作为主键',
    animal_name VARCHAR(50) COMMENT '动物名称，最大长度为50个字符',
    animal_type VARCHAR(20) COMMENT '动物类型，最大长度为20个字符',
    animal_age INT COMMENT '动物年龄，单位为岁',
    animal_weight DECIMAL(10, 2) COMMENT '动物体重，总共10位，其中2位为小数，单位为千克',
    PRIMARY KEY (animal_id)
);
```

# 执行查询
熊猫的信息
````

输出：

```
SELECT * FROM AnimalInfo WHERE animal_name = '熊猫';

年龄为2~5岁的动物
SELECT * FROM AnimalInfo  WHERE animal_age >= 2 AND animal_age <= 5;

熊猫的年龄和兔子的年龄平均值
SELECT AVG(animal_age) AS average_age FROM AnimalInfo WHERE animal_name IN ('熊猫', '兔子');
```



（5）跨语言迁移代码。

````
# 任务描述
把这段代码的功能转换为用Python代码实现（请使用Psutil库）

```sh
pgrep -f abc | xargs kill
```
# 输出代码
->
````

输出如下：

```
import psutil  
  
# 获取所有进程信息  
all_processes = psutil.process_iter(['pid', 'name'])  
  
# 遍历进程，找到名称包含'abc'的进程并杀死  
for process in all_processes:  
    if 'abc' in process.info['name']:  
        process.kill()  
  
print("Process killed successfully.")
```



（6）代码补全。

输入：

```
# 任务描述
请推测这段代码的意图，并补全这段代码。

# 代码片段
def read_and_print_file(filename):  
    with open(filename, 'r') as file:
```

输出：

```
def read_and_print_file(filename):
    with open(filename, 'r') as file:
        content = file.read()
        print(content)
```

### 7.2.2 代码优化提示

（1）代码解释。

输入：

````
# 任务描述
请简要介绍下如下代码的具体功能。

```sh
ps -ef | grep 'abc' | grep -v grep | awk '{print $2}' | xargs kill
```
````

输出：

```
这段代码的功能是查找进程列表中包含字符串'abc'的进程，并将其进程ID（PID）提取出来，然后使用xargs命令将这些PID传递给kill命令，从而终止这些进程。让我逐步解释一下：

1. ps -ef:这部分命令会列出所有正在运行的进程。-e选项表示显示所有进程，而 -f 选项表示以完整格式显示进程信息。

2. grep 'abc':这部分命令会在进程列表中搜索包含字符串'abc'的行。grep是一个文本搜索工具，用于查找匹配指定模式的行。

3. grep -v grep:这部分命令会排除掉包含字符串'grep'的行。因为我们在查找进程时，通常会得到一个包含grep自身的进程，所以我们需要排除它。

4. awk '{print $2}':这部分命令会提取每一行的第二列，即进程的PID。awk是一个文本处理工具，可以按列提取数据。

5. xargs kill:最后，xargs命令会将前面提取的 PID 传递给kill命令，以终止这些进程。

总之，这段代码的目的是查找并终止包含字符串'abc'的进程。请注意，如果你要运行这段代码，请谨慎操作，确保不会误杀其他重要的进程。
```



大语言模型也可以生成Mermaid代码以方便渲染为时序图、类图等UML图，如下提示。

```
# 任务描述
使用Mermaid时序图展示如下代码函数之间的调用关系。
<具体的代码内容>

# 输出
->
```

输出如下：

```
sequenceDiagram  
    participant U as "主程序"  
    participant C as "crawl_baidu_baike(url)"  
    participant W as "write_to_csv(data)"  
    participant R as "requests.get(url)"  
    participant BS as "BeautifulSoup(response.text, 'html.parser')"  
  
    U->>C: 调用 crawl_baidu_baike(url)  
    C->>R: 发起HTTP GET请求  
    R-->>C: 返回响应  
    C->>BS: 解析HTML  
    BS-->>C: 返回解析后的页面内容  
    C-->>U: 返回动物信息列表  
    U->>W: 调用write_to_csv(data)写入CSV  
    W-->>U: CSV文件写入完成
```



（2）代码改写。

````python
# 任务描述
根据"Modify"标记所指定的代码范围与要求，请对以下代码进行修改并请按照PEP8代码规范给代码增加注释。修改完毕后请移除原有的"Modify"修改标记。

# 代码内容
``` python
import requests
from bs4 import BeautifulSoup
import csv

# <Modify> 
#修改此处代码为 urls = ['大熊猫','狐狸','老虎','丹顶鹤']
urls = {
    '大熊猫': 'https://baike.baidu.com/item/大熊猫',
    '丹顶鹤': 'https://baike.baidu.com/item/丹顶鹤'
}
# </Modify>

headers = ['动物名称', '科属',  '生活习性', '外形特征', '分布范围']

# <Modify> 
def crawl_baidu_baike(url):
    # 修改此处代码为  url = f"https://baike.baidu.com/item/{animal}"
    response = requests.get(url)
# </Modify>
    soup = BeautifulSoup(response.text, 'html.parser')
    # 提取相关信息（根据实际网页结构进行调整）
    name = soup.find('h1', {'class': 'title'}).text  
    ke = soup.find('div', {'class': 'basic-info'}).find('p').text 
    habits = soup.find('div', {'class': 'habits-info'}).text 
    appearance = soup.find('div', {'class': 'appearance-info'}).text  
    distribution = soup.find('div', {'class': 'distribution-info'}).text 
    
    return [name, ke, habits, appearance, distribution]

# <Modify> 
def write_to_csv(data):
    pass
    # 请补全此处代码，把爬取回来解析的结果存储到csv文件里面，并保留表头
# </Modify>

if __name__ == "__main__":
    # <Modify>
    # animal_info = {} 修改为animal_info =[]
    animal_info = {}
    for animal, url in urls.items():
        info = crawl_baidu_baike(url)
        animal_info[animal] = info
    # </Modify>
    write_to_csv(animal_info)
    print('爬取完成，信息已存储至CSV文件。')   
```

# 输出代码
->
````

输出如下：

```
import requests
from bs4 import BeautifulSoup
import csv

# 定义动物网址列表
urls = ['大熊猫', '狐狸', '老虎', '丹顶鹤']

headers = ['动物名称', '科属', '生活习性', '外形特征', '分布范围']

def crawl_baidu_baike(animal):
    """
    爬取百度百科的信息

    参数：
    animal (str) ：动物名称

    返回：
    list ：包含动物名称、科属、生活习性、外形特征和分布范围的信息
    """
    url = f"https://baike.baidu.com/item/{animal}"
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    name = soup.find('h1', {'class': 'title'}).text
    ke = soup.find('div', {'class': 'basic-info'}).find('p').text
    habits = soup.find('div', {'class': 'habits-info'}).text
    appearance = soup.find('div', {'class': 'appearance-info'}).text
    distribution = soup.find('div', {'class': 'distribution-info'}).text
    return [name, ke, habits, appearance, distribution]

def write_to_csv(data):  # <Modify>: 补充完整的函数，用于将数据写入 CSV 文件
    """
    将数据写入CSV文件

    参数：
    data (list) ：动物信息数组
    """
    with open('animal_info.csv', 'w', newline = '', encoding = 'utf-8') as file:
        writer = csv.writer(file)
        writer.writerow(headers)
        for info in data:
            writer.writerow(info)

if __name__ == "__main__":
    animal_info = []
    for animal in urls:
        info = crawl_baidu_baike(animal)
        animal_info.append(info)
    write_to_csv(animal_info)
    print('爬取完成，信息已存储至CSV文件。')
```

### 7.2.3 错误检查提示

1. 错误分析。

输入：

````
# 错误描述
这段代码的功能是根据进程名称模糊匹配，找出包含"abc"的进程，获取它们的进程PID，并使用kill命令终止这些进程。然而，目前这段代码并未实现预期的效果，请找出其中的问题。

# 代码内容
``` sh
ps -ef | grep 'abc' | grep -v grep | awk '{print $4}' | xargs kill
```
# 输出
->
````

输出：

````
这段Shell脚本的代码逻辑是：

1. 使用ps -ef列出所有进程。
2. 使用grep 'abc'来筛选出进程名包含'abc'关键字的行。
3. 使用grep -v grep来排除包含grep命令自身的进程。
4. 使用awk '{print $4}'来提取每行的第4个字段，即父进程ID（PPID），而不是我们想要的进程ID（PID）。
5. 使用xargs kill来尝试终止这些进程。

问题出现在awk '{print $4}'这一步，这里应该打印的是第2个字段，即进程ID（PID），而不是第4个字段。在ps -ef的输出中，第2个字段通常是进程ID（PID），而第4个字段是父进程ID（PPID）。

正确的代码应该是：
``` sh
ps -ef | grep 'abc' | grep -v grep | awk '{print $2}' | xargs kill
```

在修正后的版本中，awk '{print $2}'正确地提取了进程ID（PID），并将其传递给xargs kill来终止这些进程。
````



（2）从错误日志分析。

````
# 任务描述
你的任务是深入剖析源代码，并仔细研究运行时产生的错误信息，从而进行详尽的错误原因分析并给出修改建议。

# 源代码
``` python
import requests
from bs4 import BeautifulSoup
import csv

urls = ['大熊猫', '狐狸', '老虎', '丹顶鹤']
def crawl_baidu_baike(animal):
    url = f"https://baike.baidu.com/item/{animal}"
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    name = soup.find('h1', {'class': 'title'}).text
    ke = soup.find('div', {'class': 'basic-info'}).find('p').text
    habits = soup.find('div', {'class': 'habits-info'}).text
    appearance = soup.find('div', {'class': 'appearance-info'}).text
    distribution = soup.find('div', {'class': 'distribution-info'}).text
    return [name, ke, habits, appearance, distribution]
```

# 运行时错误
```
/Users/jack/llm/crawl_baidu_baike.py 
Traceback (most recent call last):
    File "/Users/jack/llm/crawl_baidu_baike.py", line 49, in <module>
        info = crawl_baidu_baike(animal)
    File "/Users/jack/llm/crawl_baidu_baike.py", line 24, in crawl_baidu_baike
        name = soup.find('h1', {'class': 'title'}).text
AttributeError: 'NoneType' object has no attribute 'text'

Process finished with exit code 1
```
# 错误原因分析
->
````

输出：

```
这段代码的目标是从百度百科爬取有关不同动物的信息。然而，运行时出现了错误，导致程序终止。让我们仔细分析一下错误原因：

1. 首先，我们看到错误信息中提到了AttributeError，这意味着在代码的某一行中，我们试图访问一个不存在的属性。
2. 错误发生在以下这行代码上：name = soup.find('h1', {'class': 'title'}).text。
3. soup.find('h1', {'class': 'title'})返回了一个NoneType对象，因此无法继续调用text属性。

根据错误信息，我们可以推断问题出在soup.find('h1', {'class': 'title'})这一行。这里的目标是从页面中找到标题（动物的名称），但是它返回了None，表示没有找到匹配的元素。
```



输入：

```
import requests
from bs4 import BeautifulSoup
import csv
import json

from openai import OpenAI

client = OpenAI()
urls = ['大熊猫', '狐狸', '老虎', '丹顶鹤']
headers = ['动物名称', '科属', '生活习性', '外形特征', '分布范围']

def crawl_baidu_baike(animal):
    url = f"https://baike.baidu.com/item/{animal}"
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    introduction = soup.find('div', {'class': 'lemmaSummary_w_EOq J-summary'}).text
    return extra_tag(introduction)

def extra_tag(introduction):
    prompt = """
    # 任务描述
    从如下动物介绍文本内容中抽取字段并用JSON Array[]格式输出,无须其他解释。
    
    # 输出格式
    ['动物名称', '科属', '生活习性', '外形特征', '分布范围']
    
    #动物介绍
    {introduction}
    """
    completion = client.chat.completions.create(
        model = "gpt-3.5-turbo",
        messages = [
            {"role": "user", "content": prompt.format(introduction=introduction)}
        ],
        temperature = 0.001,
    )
    content = completion.choices[0].message.content
    print(content)
    return json.loads(content)

def write_to_csv(data): 
    with open('animal_info.csv', 'w', newline = '', encoding = 'utf-8') as file:
        writer = csv.writer(file)
        writer.writerow(headers)
        for info in data:
            writer.writerow(info)

if __name__ == "__main__":
    animal_info = []
    for animal in urls:
        info = crawl_baidu_baike(animal)
        animal_info.append(info)
    write_to_csv(animal_info)
    print('爬取完成，信息已存储至CSV文件。')
```

输出：

```
[  
  "大熊猫",  
  "熊科、大熊猫属",  
  "生活在海拔2600-3500米的茂密竹林，善爬树、爱嬉戏，每天除去一半进食的时间，剩下的一半时间多数在睡梦中度过。",  
  "体型肥硕似熊、丰腴富态，头圆尾短，体重80-120千克，最重可达180千克，体色为黑白两色，脸颊圆，有很大的“黑眼圈”，标志性的内八字的行走方式，皮肤厚可达10毫米。",  
  "主要栖息地是中国四川、陕西和甘肃的山区，中国旅居国外的大熊猫总数达到63只（截至2023年10月）。" 
]
```



2. 代码审查。

输入：

````
# 任务描述
作为一款先进的代码质量智能分析工具，你能够发现代码中潜在缺陷并提供优化建议。你的职责范围包括：
1. 缺陷分析：自动发现代码中可能存在的语法或逻辑错误。
2. 重构建议：识别代码中可以优化的部分，提供改进结构或逻辑的建议。
3. 复杂度评估：评估代码的复杂度，帮助你写出更简洁、更易于理解的代码。
4. 安全性分析：检测潜在的安全漏洞，并提供修复建议。

现在请你对如下代码进行扫描分析。
# 代码内容
``` python
import psutil  
  
# 获取所有进程信息  
all_processes = psutil.process_iter(['pid', 'name'])  
  
# 遍历进程，找到名称包含'abc'的进程并杀死  
for process in all_processes:  
    if 'abc' in process.info['name']:  
        process.kill()  
  
print("Process killed successfully.")
```
````

输出：

```
# 代码分析报告
## 缺陷分析
在提供的代码中，存在几个潜在的问题：
1. psutil.process_iter(['pid', 'name'])是不正确的，因为 psutil.process_iter()函数不接受任何参数来指定要获取的进程信息字段。通常，我们需要通过访问每个进程的info属性或使用 as_dict(attrs = [...])来获取详细信息。
2. 在process.info['name']中，process.info是旧版本的Psutil用法，新版本中可能需要直接使用process对象的属性，如process.name()。

## 重构建议
- 可以考虑引入一个函数来处理进程的查找和杀死，以提高代码的可读性和可重用性。
- 添加适当的日志记录，以便跟踪哪些进程被尝试杀死，以及操作是否成功。

## 复杂度评估
代码的复杂度不高，逻辑简单直接。但重构后的版本可以通过引入函数和异常处理来提高可维护性。

## 安全性分析
- 杀死进程是一个敏感操作，应确保只有具有足够权限的用户才能执行此脚本，以防止误杀重要系统进程。
- 脚本应记录尝试被杀死进程信息，以便在出现问题时能够追踪。
```



# 第8章 推理提示

## 8.2 基础思维链

### 8.2.1 零样本提示

```
// 原始问题
一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？

// 错误答案
一共有29只动物，15只大熊猫和14只金丝猴。
```

### 8.2.2 少样本提示

例子1：利用少样本提示翻译文本。

输入：

```
// 少样本示例
问: 熊猫的主要食物是竹子，它们每天要吃很多竹子。
答: The main food of pandas is bamboo, and they have to eat a lot of bamboo every day

问: 一只成年大熊猫的体重为90~130千克，而一只初生的大熊猫幼仔平均体重约为100克，是妈妈体重的千分之一。
答: An adult giant panda weighs between 90-130kg, while a newborn panda cub weighs around 100g on average, which is 0.1% of its mother’s weight.

// 正式提问
问: 大熊猫是地球上生存了至少800万年的动物，被誉为“活化石”和“中国国宝”，世界自然基金会的形象大使。
答: 
```

输出：

```
The giant panda is an animal that has survived on Earth for at least 8 million years, and is known as a "living fossil" and a "Chinese national treasure". It is also the image ambassador of the World Wildlife Fund
```

例子2：利用少样本提示进行数学推理。

输入：

```
问: 一个人每天吃两个苹果，一个月（按30天计算）能吃多少个苹果？
答: 60个

问: 一个人有4种水果，分别是苹果、香蕉、橘子和西瓜，他每次只能吃一种水果，然后换一种水果，西瓜是其中最大的水果，那么他吃完所有水果的顺序有多少种？
答: 24种

问: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？
```

输出：

```
答: 一共有29只动物，15只大熊猫和14只金丝猴。
```

### 8.2.3 少样本思维链提示

 输入：

```
//两个小样本思维链示例
问：一个人每天吃两个苹果，不管是红色的还是绿色的，一个月能吃多少个苹果？
答：首先，我们知道一个人每天吃两个苹果。然后，我们需要知道一个月有多少天。通常情况下，一个月可能有28天、30天或31天。所以，如果一个月有30天的话，那么这个人就会吃到60个苹果（2苹果/天 × 30天/月 = 60苹果/月）。如果一个月有31天的话，那么这个人就会吃到62个苹果（2苹果/天 × 31天/月 = 62苹果/月）。而如果是二月份（非闰年），那么这个人就会吃到56个苹果（2苹果/天 x 28天/月 = 56苹果/月

问：一个人有四种水果，分别是苹果、香蕉、橘子和西瓜，他每次只能吃一种水果，然后换一种水果，西瓜是其中最大的水果，那么他吃完所有水果的顺序有多少种？
答：首先，我们知道这个人有四种水果：苹果、香蕉、橘子和西瓜。他每次只能吃一种水果，然后换一种水果。那么，他吃完所有水果的顺序有多少种呢？这其实是一个排列组合的问题。四种水果，每种只能吃一次，那么总的吃法就是4的阶乘，也就是4*3*2*1=24种。

//正式提问
问:如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午保护区增加了4只大熊猫和 6 只金丝猴，那么保护区一共有多少只动物？
```

输出：

```
答：早上，保护区有15只大熊猫和10只金丝猴，所以一共有25只动物。中午，保护区增加了4只大熊猫和6只金丝猴，所以一共有35只动物（15+4=19只大熊猫，10+6=16只金丝猴，19+16=35只动物）
```

### 8.2.4 零样本思维链提示

第一阶段：推理抽取。

```
// 原始问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？

// 推理生成触发器
让我们一步一步思考。
```

输出如下：

```
早上：15只大熊猫和10只金丝猴
中午：15 + 4 = 19只大熊猫，10 + 6 = 16只金丝猴
因此，自然保护区共有19只大熊猫和16只金丝猴，共有35只动物。
```

第二阶段：答案抽取。

```
问: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？

答: 早上：15只大熊猫和10只金丝猴，中午： 15 + 4 = 19只大熊猫，10 + 6 = 16只金丝猴，因此，自然保护区一共有19只大熊猫和16只金丝猴，一共有35只动物。

因此答案是（数字）：
```

输出：

```
35
```



2. 一阶段零样本思维链

输入：

```
// 原始问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么自然保护区一共有多少只动物？

// 推理生成触发器+答案生成触发器
让我们一步一步思考，并给出最后答案。
```

输出：

```
根据题目描述，早上自然保护区有15只大熊猫和10只金丝猴。中午自然保护区增加了4只大熊猫和6只金丝猴。
首先，我们计算大熊猫的数量。早上有15只大熊猫，中午增加了4只大熊猫，所以大熊猫的总数为15 + 4 = 19只。
接下来，我们计算金丝猴的数量。早上有10只金丝猴，中午增加了6只金丝猴，所以金丝猴的总数为10 + 6 = 16只。
最后，我们将大熊猫和金丝猴的数量相加得到自然保护区动物的总数：19 + 16 = 35只。
所以，自然保护区一共有35只动物。
```



输入：

```
// 原始问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？

// 推理生成触发器 + 答案生成触发器
@分析（详细给出分析过程）
@结论（最终答案）
```

输出：

```
分析：
已知自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴。

结论：
根据加法原理，可得这个自然保护区一共有15 + 10 + 4 + 6 = 35只动物。
```

---

## 8.3 进阶思维链

### 8.3.1 思维表提示

第一阶段：表格生成。

输入：

```
// 原始问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？ 

请按照如下Markdown格式拆解子问题，并针对子问题解决：
| 步骤 | 子问题  | 分析计算过程 | 结果 |`
```

输出：

```
| 步骤 | 子问题 | 分析计算过程 | 结果 |
| --- | --- | --- | --- |
| 1 | 早上的动物数量 | 自然保护区已有的大熊猫数量 + 自然保护区已有的金丝猴数量 | 15 + 10 = 25 |
| 2 | 中午增加的动物数量 | 新增的大熊猫数量 + 新增的金丝猴数量 | 4 + 6 = 10 |
| 3 | 动物总数量 | 早上的动物数量 + 中午增加的动物数量 | 25 + 10 = 35 |
```

第二阶段：答案抽取。

输入：

```
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？

| 步骤 | 子问题 | 分析计算过程 | 结果 |
| --- | --- | --- | --- |
| 1 | 早上的动物数量 | 自然保护区已有的大熊猫数量 + 自然保护区已有的金丝猴数量 | 15 + 10 = 25 |
| 2 | 中午增加的动物数量 | 新增的大熊猫数量 + 新增的金丝猴数量 | 4 + 6 = 10 |
| 3 | 动物总数量 | 早上的动物数量 + 中午增加的动物数量 | 25 + 10 = 35 |

综上，我们得出答案是（数字）？
```

 输出：

```
35
```

### 8.3.2 自我一致提示

```python
from openai import OpenAI
client = OpenAI()

response = client.chat.completions.create(
    model = "gpt-3.5-turbo",
    messages = [
        {"role": "user",  "content":"如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，那么这个自然保护区一共有多少只动物？让我们一步一步思考，并给出最后解答。" }
    ]
    temperature = 0.5,
    max_tokens = 1024,
    top_p = 1,
    n = 5
)
for i, item in enumerate(response["choices"]):
    print("采样", i+1, "-" * 15)
    print(item["text"].strip())
```

输出：

```
采样1 ---
步骤1：首先，我们知道自然保护区有15只大熊猫和10只金丝猴。
步骤2：接着，中午自然保护区增加了4只大熊猫和6只金丝猴。
步骤3：最后，我们可以把15只大熊猫和10只金丝猴加上4只大熊猫和6只金丝猴，得到总共有19只大熊猫和16只金丝猴，所以自然保护区一共有35只动物。

采样2 ---
步骤1：我们首先确定有15只大熊猫和10只金丝猴，一共25只动物。
步骤2：增加4只大熊猫和6只金丝猴，一共有25 + 4 + 6 = 35只动物。
答案：自然保护区一共有35只动物。

采样3 ---
第一步：原本自然保护区有多少只动物？
答：原本自然保护区有15只大熊猫和10只金丝猴，一共有25只动物。

第二步：中午自然保护区增加了多少只动物？
答：中午自然保护区增加了4只大熊猫和6只金丝猴，一共增加了10只动物。

第三步：最终自然保护区一共有多少只动物？
答：最终自然保护区一共有25 + 10 = 35只动物。

采样4 ---
答：自然保护区一共有29只动物，其中有19只大熊猫和16只金丝猴。
 
采样5 ---
答：自然保护区一共有29只动物，包括15只大熊猫和14只金丝猴。
```

### 8.3.3 由少至多提示

第一阶段：分解问题。

（1）零样本提示拆解：

输入：

```
# 任务描述
你的任务是将以下用户的提问拆解成子问题，以便通过解决所有子问题来得出最终答案。

# 用户提问
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴,自然保护区一共有多少只动物？

# 答案格式
1. 子问题1
2. 子问题2
```

输出：

```
1. 早上自然保护区有多少只动物？
2. 中午自然保护区增加了多少只大熊猫？
3. 中午自然保护区增加了多少只金丝猴？
4. 中午自然保护区一共有多少只动物？
```

---

（2）少样本示例拆解

```
# 任务描述
您的主要职责是深入剖析“用户提问”，识别出成功解答该提问所需预先解决的各个子问题，并根据所提供的示例，进行系统的拆解与分析。

# 例子1
用户提问：
如果一个人有两个儿子，每个儿子都有一个姐姐，那么这个人一共有几个孩子？
拆解结果：
1.首先要判断问题中涉及的人物的身份和相互之间的关系。
2.然后计算关系中儿子的数量。
3.最后计算关系中女儿的数量。

# 例子2
用户提问：
小明有6个苹果，小雷有4个李子，中午他们把各自的一半水果送给了小熙，那么小熙吃了2个李子，请问小熙还有多少水果。
拆解结果：
小明有6个苹果，小雷有4个李子，他们一共有多少水果？
小明和小雷各自给了小熙多少水果？
小熙一共得到了多少水果？
小熙吃了2个李子后还剩下多少水果？

# 用户提问
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午增加了4只大熊猫和6只金丝猴，这个自然保护区一共有多少只动物？

# 拆解结果
->
```

输出：

```
1.首先要计算自然保护区原有的大熊猫数量和金丝猴数量。
2.然后计算中午自然保护区增加的大熊猫数量和金丝猴数量。
3.最后计算自然保护区一共有多少只动物，包括大熊猫和金丝猴。
```

---

（3）零样本思维链拆解

```
// 原始问题
问：如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴

// 问题拆解触发器，
为了解决“自然保护区一共有多少只动物？”这个问题，首先需要解决
```

输出：

```
// 拆解出来的子问题
一、最初有多少只动物？
二、增加了多少只动物？
```

问题变换优化的提示

输入：

```
# 任务描述
请你提取一下用户提问的描述句和提问句。

# 用户提问
请计算一下自然保护区总共有多少动物。如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴

# 输出格式
描述句: 请引用原文
提问句: 请引用原文
```

输出：

```
描述句: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴。
提问句: 请计算一下自然保护区总共有多少动物。
```

---

第二阶段：解决子问题。

输入：

```
// 原始问题，拼接上一个拆解的子问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴
问：最初有多少只动物？
```

输出：

```
答：最初有15只大熊猫和10只金丝猴，共25只动物
```

输入：

```
// 原始问题，拼接上一个拆解的子问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴
问：增加了多少只动物？
```

输出：

```
增加了4只大熊猫和6只金丝猴，共10只动物。
```

---

第三阶段：汇总最终答案。

```
/ 原始问题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴

// 子问题+答案拼接
问: 最初有多少只动物？
答: 最初有15只大熊猫和10只金丝猴，共25只动物。
问: 增加了多少只动物？
答: 增加了4只大熊猫和6只金丝猴，共10只动物。

// 汇总答案
综上，自然保护区一共有多少只动物？
```

输出：

```
答: 自然保护区一共有35只动物。
```

### 8.3.4 自问自答提示

```
// 原始问题
问题：原始问题。

// 拆解并解决子问题
是否需要拆解子问题：是否需要拆解子问题。
后续问题：拆解子问题。
中间答案：子问题答案。

// 汇总答案
因此最终答案是：最终答案。
```

```
// 少样本示例启发大语言模型拆解问题
问题：如果一个正方形的面积是64平方厘米，那么它的周长是多少？
是否需要拆解子问题：是
后续问题：一个正方形的边长等于它的面积开平方根，那么64平方厘米的正方形的边长是多少？
中间答案：8厘米
是否需要拆解子问题：是
后续问题：一个正方形的周长等于它的边长乘以4，那么8厘米的正方形的周长是多少？
中间答案：32厘米
是否需要拆解子问题：否
因此最终答案是：32厘米

// 正式提问
问题：刘翔获得奥运金牌那一年国际奥委会主席是谁？
是否需要拆解子问题：
```

```
// 第1轮
是
子问题：刘翔获得奥运金牌的那一年是哪一年？
答案：在2004年雅典奥运会上，刘翔成了中国第一位奥运会田径金牌得主。在2004年雅典奥运会男子110米栏比赛中，刘翔一路领先，最终以12秒91的成绩夺得冠军（调用搜索）。

// 第2轮
是否需要拆解子问题：是
子问题：2004年国际奥委会主席是谁？
答案：2004年雅典奥运会_全球百科，雅典奥组委主席安杰洛普洛斯夫人和国际奥委会主席罗格分别致辞。希腊总统斯特凡诺普洛斯宣布本届奥运会正式开幕。(调用搜索)

// 第3轮
是否需要拆解子问题：否
// 模型在这里给出了无须进一步拆解子问题的判断
```

```
// 汇总给出最终的答案-请求大语言模型
{代入第1轮，第2轮，第3轮的子问题和答案}
因此最终答案是：罗格
```

## 8.4 高阶思维链

### 8.4.1 思维树提示

第一阶段：问题分解。

输入：

```
# 任务描述
你的任务是对用户提问进行子问题拆解，以达到通过求解所有子问题能给出最终答案的目的。

# 用户提问
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，自然保护区一共有多少只动物？

# 答案格式
1.子问题1
2.子问题2
……（根据需要确认是否继续拆解子问题）
```

输出：

```
子问题1: 早上的时候自然保护区有多少只动物？
子问题2: 中午自然保护区新增加了多少只动物？
子问题: 晚上有多少只动物被送出了动物园？
```

第二阶段：扩展子节点。

1.想法生成。

（1）深度生成：

```
// 问题
问题：如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，自然保护区一共有多少只动物？

// 当前状态或者思维链
子问题：早上的时候自然保护区有多少只动物？

// 下一个思考
针对"子问题"请一步一步给出这个问题的答案
```

输出：

```
解决思路：早上自然保护区有15只大熊猫和10只金丝猴，因此早上自然保护区一共有25只动物。答案：25只动物。
```

（2）广度生成

输入：

```
// 问题
问题：如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，自然保护区一共有多少只动物？

// 状态
子问题: 早上的时候自然保护区有多少只动物？

// k个可能的思考
针对[子问题]请提出几种不同的解决思路，并给出答案。

# 答案格式
1.思路1
2.思路2
……（根据需要确认是否需要给出更多的思路）
```

输出：

```
1. 思路1: 早上自然保护区有15只大熊猫和10只金丝猴，因此早上自然保护区一共有25只动物。
2. 思路2: 早上自然保护区有15只大熊猫，加上中午增加的4只大熊猫和6只金丝猴，因此早上自然保护区一共有25只动物。
```

---

2.状态评估

（1）深度状态评估

输入：

```
问题: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园。
子问题：中午自然保护区新增加了多少只动物？
子问题答案：中午之后自然保护区增加了19只大熊猫和16只金丝猴。

请评估上述子问题和子问题答案是否正确（请先回答正确/不正确）
```

输出：

```
子问题答案: 不正确
中午之后自然保护区增加了4只大熊猫和6只金丝猴，而不是19只大熊猫和16只金丝猴。
```

（2）广度状态评估

输入：

```
// 问题
问题: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，自然保护区一共有多少只动物？

// k个状态
子问题: 中午自然保护区新增加了多少只动物？
有以下解决思路：    
    1.思路1：计算减少的动物数量，15只大熊猫减去8只，10只金丝猴减去0只，一共减少8只动物。
    2.思路2：计算增加的动物数量，15只大熊猫加4只，10只金丝猴加上6只，一共增加10只动物。

// 最优或最差状态
上述方案中你认为能正确地解决问题思路是？
```

输出：

```
思路2：计算增加的动物数量，15只大熊猫加4只，10只金丝猴加上6只，一共增加10只动物。
```

---

第三阶段：生成答案。

输入：

```
// 问题
问题: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴,晚上有8只动物被送出了动物园

// 子问题和答案
解决该问题的过程如下:

子问题1: 早上的时候自然保护区有多少只动物？
答案: 早上自然保护区有15只大熊猫，加上中午增加的4只大熊猫和6只金丝猴，因此早上自然保护区一共有25只动物。

子问题2: 中午之后自然保护区一共增加了多少只动物？
答案: 计算增加的动物数量，15只大熊猫加4只，10只金丝猴加上6只，一共增加10只动物。

子问题3: 晚上有多少只动物被送出了动物园？
答案: 根据题目中的信息，早上有15只大熊猫和10只金丝猴，中午增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，因此晚上被送出的动物数量为8只。

// 得出最终答案
因此，自然保护区一共有多少只动物？
```

输出：

```
答案: 根据以上计算，早上自然保护区一共有25只动物，中午增加了10只动物，晚上有8只动物被送出了动物园，因此晚上自然保护区一共有27只动物。
```

### 8.4.2 推理-行动提示

```
# 任务描述
请按照"回答格式"，根据用户输入从工具列表中选择合适的工具解决问题，工具的参数格式如下：

@工具名称(参数1, 参数2, ...): 工具功能描述

# 工具描述
@定位(): 获取用户当前的定位城市
@天气(城市名称): 查看天气预报
@导航(起点，终点): 规划地点A到地点B的驾驶路线
@计算器(数字1，运算符，数字2): 进行简单的四则运算
@时钟(): 获取当前的日期和时间
@搜索(搜索关键词): 当以上工具都无法使用时，尝试使用这个搜索引擎工具
@补充(需要补充的问题): 当你回答问题的依赖信息不足时，调用这个工具可以让人工给你补充一些信息
@自答(需要回答的问题): 当以上工具无法使用时，可以依靠你自己的知识直接给出答案，请注意输出事实不要杜撰

# 回答格式
思考: 请保持思考，结合上下文背景，请首先判断解决该问题的素材是否满足，然后给出要解决这个问题的方案和分析过程，
动作: @工具名称(参数1, 参数2, ...)。每次动作只选择一个工具。工具列表"工具描述"
观察: <工具返回的结果>

...（这个“思考-动作-输入-观察”的循环可以重复N次）

思考: 最后，已经得到最终结果了
最终结果: 针对原始问题，输出最终结果

# 用户问题
问题: {question}

# 回答过程
<第1轮>
```

---

例子1：北京到襄阳怎么走？襄阳本地有哪些好玩的地方？

```
# 回答过程
<第1轮>
思考: 根据用户的问题，首先需要通过定位工具确定用户当前所在的城市，然后使用导航工具规划从北京到襄阳的驾驶路线。接下来，可以使用搜索工具来获取襄阳本地的旅游景点信息。
动作: @定位()
观察: 根据定位结果，得知用户当前所在城市为北京。

<第2轮>
思考: 现在已经知道用户当前所在城市是北京，下一步可以使用导航工具来规划从北京到襄阳的驾驶路线。
动作: @导航(北京，襄阳)
观察: 导航工具返回了从北京到襄阳的驾驶路线。

<第3轮>
思考: 现在已经得到了从北京到襄阳的驾驶路线，接下来可以使用搜索工具来获取襄阳本地的旅游景点信息。
动作: @搜索(襄阳旅游景点)
观察: 襄阳市的旅游景点有：1. 襄阳古城墙... 2. 古隆中景区... 3. 钟鼓楼...

<第4轮>
思考: 已经得到了襄阳本地的旅游景点信息，可以将这些信息整理后输出给用户。
最终结果: 从北京到襄阳的驾驶路线如下：起点为北京，终点为襄阳，走京开高速→G45大广高速→S83兰南高速，距离1059.36千米，耗时10小时37分钟。
襄阳本地的好玩的地方有：1. 襄阳古城墙... 2. 古隆中景区... 3. 钟鼓楼...
```

---

例子2：王军老师的身高乘以2是多少，并以王老师身高为题做一首诗。

```
<第1轮>
思考: 需要获取王老师的身高，可以使用@补充工具
动作: @补充(王老师身高)
观察: 王老师身高为180cm

<第2轮>
思考: 需要计算180cm乘以2的结果，可以使用@计算器工具
动作: @计算器(180cm,*,2)
观察: 180cm乘以2的结果为360cm

<第3轮>
思考: 需要根据360cm写一首诗，可以使用@自答工具
动作: @自答(根据360cm写一首诗)
观察: 王老师高达三百六十，他的身材犹如一棵树，他的脚步踏遍大江南北，他的知识智慧比满天星。

<第4轮>
思考: 最后，已经得到最终结果了
最终结果: 王老师的身高是王老师身高为180cm，给王老师写的诗是：王老师高达三百六十，他的身材犹如一棵树，他的脚步踏遍大江南北，他的知识智慧比满天星。
```

### 8.4.3 自动思维链提示

第一阶段：构建候选示例样本。

```
一个人每天吃两个苹果，不管是红色的还是绿色的，一个月能吃多少个苹果？
一个人在一年中的每个月都买了一本书，但是在2月和8月他买了两本书，其中有3本是小说，其余的都是散文，那么这个人一年中一共买了多少本书？
一个人有5种颜色的衣服，分别是红色、蓝色、绿色、黄色和黑色，他每天只穿一种颜色的衣服，他最喜欢的颜色是蓝色，那么他在一个星期内能有多少种不同的穿衣搭配？
一个人有4种水果，分别是苹果、香蕉、橘子和西瓜，他每次只能吃一种水果，然后换一种水果，他最不喜欢吃的水果是西瓜，那么他吃完所有水果的顺序有多少种？
一个人有两个骰子，每个骰子有6个面，分别是1、2、3、4、5和6，他每次只能掷一个骰子，然后记录下来，那么他掷出两个相同数字的概率是多少？
一个人有10个朋友，分别叫作A、B、C、D、E、F、G、H、I和J，他每天只能给其中一个朋友发一条微信消息，然后换一个朋友，那么他在一个星期内能给多少个朋友发消息？
```

---

第二阶段：候选示例样本聚类。

方法1：使用“语义向量化+聚类算法”

```
from sentence_transformers import SentenceTransformer
from sklearn.cluster import KMeans

st = SentenceTransformer('bert-base-nli-mean-tokens')

question_list = [
  "上述问题文本列表"，
  "...."，
] 

#使用SentenceTransformer进行文本向量化
X = []
for question in question_list:
      question_vec = st.encode(question)
       X.append(question_vec)

#使用sklearn库的Means算法进行聚类
km = KMeans(n_clusters = 3).fit(X)
cluster_centers = km.cluster_centers_
```

方法2：使用大语言模型直接进行语义聚类。

输入：

```
把以下问题聚类为3个簇，说明理由：

<第一阶段的数据集问题列表>
```

输出：

```
将以上问题聚类为3个簇的理由如下：

簇1：计算问题
- 一个人每天吃两个苹果，不管是红色的还是绿色的，一个月能吃多少个苹果？
- 一个人在一年中的每个月都买了一本书，但是在2月和8月他买了两本书，其中有3本是小说，其余的都是散文，那么这个人一年中一共买了多少本书？

簇2：组合问题
- 一个人有5种颜色的衣服，分别是红色、蓝色、绿色、黄色和黑色，他每天只穿一种颜色的衣服，他最喜欢的颜色是蓝色，那么他在一个星期内能有多少种不同的穿衣搭配？
- 一个人有4种水果，分别是苹果、香蕉、橘子和西瓜，他每次只能吃一种水果，然后换一种水果，西瓜是其中最大的水果，那么他吃完所有水果的顺序有多少种？

簇3：排列问题
- 一个人有两个骰子，每个骰子有6个面，分别是1、2、3、4、5和6，他每次只能掷一个骰子，然后记录下来，那么他掷出两个相同数字的概率是多少？
- 一个人有10个朋友，分别叫作A、B、C、D、E、F、G、H、I和J，他每天只能给其中一个朋友发一条微信消息，然后换一个朋友，那么他在一个星期内能给多少个朋友发消息？

以上问题通过对问题类型的分类，可以将其聚类为上述3个簇，便于进一步分析和解决。
```

---

利用大语言模型从每个聚类簇中选择一个代表性问题

输入：

```
从下面的聚类的每个簇里面各选择一个具有代表性的问题，说明理由：
<问题语义聚类中的结果>
```

输出：

```
簇1代表性问题：一个人每天吃两个苹果，不管是红色的还是绿色的，一个月能吃多少个苹果？

簇2代表性问题：一个人有4种水果，分别是苹果、香蕉、橘子和西瓜，他每次只能吃一种水果，然后换一种水果，西瓜是其中最大的水果，那么他吃完所有水果的顺序有多少种？

簇3代表性问题：一个人有10个朋友，分别叫作A、B、C、D、E、F、G、H、I和J，他每天只能给其中一个朋友发一条微信消息，然后换一个朋友，那么他在一个星期内能给多少个朋友发消息？
```

第三阶段：示例采样。

```
问: 一个人每天吃两个苹果，不管是红色的还是绿色的，一个月能吃多少个苹果？
答: 首先，我们知道一个人每天吃两个苹果。然后，我们需要知道一个月有多少天。通常情况下，一个月可能有28天、30天或31天。所以，如果一个月有30天的话，那么这个人就会吃到60个苹果（2苹果/天 × 30天/月 = 60苹果/月）。如果一个月有31天的话，那么这个人就会吃到62个苹果（2苹果/天 × 31天/月 = 62苹果/月）。而如果是二月份（非闰年），那么这个人就会吃到56个苹果（2苹果/天 × 28天/月 = 56苹果/月）

问: 一个人有4种水果，分别是苹果、香蕉、橘子和西瓜，他每次只能吃一种水果，然后换一种水果，西瓜是其中最大的水果，那么他吃完所有水果的顺序有多少种？
答: 首先，我们知道这个人有4种水果：苹果、香蕉、橘子和西瓜。他每次只能吃一种水果，然后换一种水果。那么，他吃完所有水果的顺序有多少种呢？这其实是一个排列组合的问题。4种水果，每种只能吃一次，那么总的吃法就是4的阶乘，也就是432 * 1 = 24种。

问: 一个人有10个朋友，分别叫作A、B、C、D、E、F、G、H、I和J，他每天只能给其中一个朋友发一条微信消息，然后换一个朋友，那么他在一个星期内能给多少个朋友发消息？
答: 这个问题的答案取决于一周的定义。如果我们按照一周7天来计算，那么他每天给一个朋友发消息，一周内就可以给7个朋友发消息。但是，如果我们按照一周5天（工作日）来计算，那么他一周内可以给5个朋友发消息。所以，他在一个星期内能给5-7个朋友发消息，具体取决于你如何定义“一个星期”。
```

---

第四阶段：生成答案。

输入：

```
// 采样的示例
<第三阶段采样结果>

// 实际要问的问题
问: 如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴,晚上有8只动物被送出了动物园，2只大熊猫提前开始呼呼睡觉,自然保护区一共有多少只动物？
  
答: 首先，我们知道自然保护区开始时有15只大熊猫和10只金丝猴，总共25只动物。然后，中午自然保护区增加了4只大熊猫和6只金丝猴，增加了10只动物。所以，到中午时，自然保护区里总共有35只动物。晚上有8只动物被送出了动物园，所以剩下27只动物。然后，2只大熊猫提前开始呼呼睡觉，但是它们仍然在自然保护区内，所以最后自然保护区一共有27只动物。
```

输出：

```
首先，我们知道自然保护区开始时有15只大熊猫和10只金丝猴，总共25只动物。然后，中午自然保护区增加了4只大熊猫和6只金丝猴，增加了10只动物。所以，到中午时，自然保护区里总共有35只动物。晚上有8只动物被送出了动物园，所以剩下27只动物。然后，2只大熊猫提前开始呼呼睡觉，但是它们仍然在自然保护区内，所以最后自然保护区一共有27只动物。
```

## 8.5 尝试构建自己的思维链

### 8.5.1 自由辩论提示

输入：

```
下面是一场关于解决问题的辩论，由红蓝双方交替发言，发言内容可以包括：
1）指出并批评对方错误
2）分析双方回答中的共识，重新论证并给出最终答案

问题：如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，2只大熊猫提前开始呼呼睡觉，自然保护区一共有多少只动物？

红方先发言：
```

红方：

```
红方发言：

// 实际上蓝方在此之前并没有发言而是自己的臆想
首先，我要指出蓝方的错误。蓝方认为自然保护区一共有25只动物，这是一个错误的答案。因为蓝方没有考虑到晚上有8只动物被送出了动物园，这意味着自然保护区的动物数量减少了8只。所以，正确的答案应该是25 - 8 = 17只动物。

其次，我要分析双方回答中的共识。双方都同意早上自然保护区有15只大熊猫和10只金丝猴，中午自然保护区增加了4只大熊猫和6只金丝猴。这些信息可以用数学公式表示为：

早上：大熊猫 = 15，金丝猴 = 10
中午：大熊猫 = 15+4=19，金丝猴 = 10 + 6 = 16

最后，我要重新论证并给出最终答案。除了晚上有8只动物被送出了动物园，还有一个细节是2只大熊猫提前开始呼呼睡觉。这意味着这2只大熊猫不属于自然保护区的动物数量，因为它们已经不在自然保护区内了。所以，最终的答案应该是：

晚上：大熊猫 = 19 - 8 - 2 = 9，金丝猴 = 16 - 0 = 16
总数：9 + 16 = 25

因此，我认为自然保护区一共有25只动物是正确的答案。
```

蓝方：

```
蓝方发言：

我不同意红方的答案，我认为红方的错误有两个方面：

一是红方没有说明晚上被送出了动物园的8只动物是什么种类，这是一个重要的信息，因为不同种类的动物对自然保护区的动物数量有不同的影响。如果被送出的8只动物都是大熊猫，那么自然保护区的大熊猫数量就会减少8只，但如果被送出的8只动物都是金丝猴，那么自然保护区的金丝猴数量就会减少8只。所以，红方的答案是不完整的，需要更多的信息才能确定。

二是红方错误地认为2只大熊猫提前开始呼呼睡觉就不属于自然保护区的动物数量，这是一个错误的假设，因为这2只大熊猫并没有离开自然保护区，它们只是在自然保护区内睡觉而已。所以，这2只大熊猫仍然属于自然保护区的动物数量，不能被排除在外。

接下来，我要分析双方回答中的共识。双方都同意早上自然保护区有15只大熊猫和10只金丝猴，中午自然保护区增加了4只大熊猫和6只金丝猴。这些信息可以用数学公式表示为：

早上：大熊猫 = 15，金丝猴=10
中午：大熊猫 = 15 + 4 = 19，金丝猴 = 10 + 6 = 16

最后，我要重新论证并给出最终答案。根据我的分析，晚上被送出了动物园的8只动物是什么种类是关键信息，如果没有这个信息，就无法确定自然保护区的动物数量。所以，我认为这个问题没有一个确定的答案，需要更多的信息才能解决。
```

---

第二阶段：裁判总结

输出：

```
// 第一阶段发言过程
红方: ……
蓝方: ……
红方: ……
蓝方: ……

// 裁判总结
裁判总结：基于上述对双方发言进行总结，并判定给出最终的答案
```

输入：

```
裁判总结:

这是一场关于解决问题的辩论，红方和蓝方交替发言，指出并批判对方错误，分析双方回答中的共识，重新论证并给出最终答案。

红方认为自然保护区一共有25只动物，蓝方认为自然保护区一共有27只动物。双方的分歧主要在于如何理解自然保护区一共有多少只动物的定义，以及如何处理晚上被送出了动物园的8只动物是什么种类和2只大熊猫提前开始呼呼睡觉的情况。

经过主席的仔细评判，最终的答案是：**自然保护区一共有27只动物**。原因如下：……（略）

因此，根据问题中给出的所有信息，最终的答案应该是：

晚上：大熊猫 = 19 - 8 = 11，金丝猴 = 16 - 0 = 16
总数：11 + 16 = 27

感谢红方和蓝方的精彩发言，也感谢观众们的关注和支持。这场辩论到此结束。谢谢大家！
```

### 8.5.2 圆桌会议提示

第一阶段：主持人陈述问题。

```
# 任务描述
下面是一场关于解决问题的圆桌会议，参会人有主持人、动物管理员、数学老师和物理老师。每位参会者需要独立思考，禁止背离事实地杜撰答案，每人每次发言不超过100字。

# 会议主题
如果一个自然保护区有15只大熊猫和10只金丝猴，早上这15只大熊猫获得了喂食，中午自然保护区增加了4只大熊猫和6只金丝猴，晚上有8只动物被送出了动物园，2只大熊猫提前开始呼呼睡觉，自然保护区一共有多少只动物？

# 会议记录
主持人发言：我们的目标是找出正确的答案，并解释我们的思路和方法，请大家踊跃发言。
```

第二阶段：参会人员轮流发言。

输入：

```
下面有请生物老师发言。
```

输出：

```
我认为这个问题可以用简单的算术来解决。首先，我们要知道自然保护区一开始有多少只动物，也就是15只大熊猫和10只金丝猴，一共是25只。然后，我们要加上中午增加的动物，也就是4只大熊猫和6只金丝猴，一共是10只。所以，中午的时候，自然保护区有25 + 10 = 35只动物。最后，我们要减去晚上被送出的动物，也就是8只，不管是什么种类。所以，晚上的时候，自然保护区有35 - 8 = 27只动物。至于2只大熊猫提前睡觉，这并不影响动物的总数，所以可以忽略。因此，我认为正确的答案是27只动物。
下面有请数学老师发言。
```

输出：

```
我同意生物老师的答案，但是我想用一个不同的方法来解决这个问题。我认为这个问题可以用代数来解决。首先，我们设x为大熊猫的数量，y为金丝猴的数量。根据题目，我们有以下方程：

x + y = 25 （一开始的动物数量）
x + 4 = y + 6 （中午增加的动物数量）
x - y = 2 （晚上被送出的动物数量）

我们可以用消元法来解这个方程组，得到：

x = 17 （大熊猫的数量）
y = 10 （金丝猴的数量）

所以，晚上的时候，自然保护区有17 + 10 = 27只动物。这个答案和生物老师的答案一致。因此，我认为正确的答案是27只动物。

下面有请物理老师发言。
```

输出：

```
我也同意生物老师和数学老师的答案，但是我想用一个更有趣的方法来解决这个问题。我认为这个问题可以用物理学的概念来解决。首先，我们要假设自然保护区是一个封闭的系统，没有能量和物质的交换。然后，我们要用动物的质量来代替动物的数量，因为质量是一个守恒的量。根据题目，我们可以估计每只大熊猫的质量是100千克，每只金丝猴的质量是5千克。所以，我们有以下公式：

M = 100x + 5y （自然保护区的总质量）
M = 100(15) + 5(10) （一开始的总质量）
M = 100(15+4) + 5(10+6) （中午的总质量）
M = 100(x-8) + 5(y-8) （晚上的总质量）

我们可以用等式法来解这个公式组，得到：

x = 17 （大熊猫的数量）
y = 10 （金丝猴的数量）

所以，晚上的时候，自然保护区有17 + 10 = 27只动物。这个答案和生物老师和数学老师的答案一致。因此，我认为正确的答案是27只动物。
```

第三阶段：主持人总结答案。

输入：

```
主持人总结发言：……最终我们形成的答案是：

经过我们的讨论，我们得出了一个一致的答案，那就是**27只动物**。我们用了不同的学科知识和方法来解决这个问题，展示了我们的多元思维和创造力。我感谢所有的参与者，你们都做得很好。我希望这次会议能够启发我们对动物保护的关注和行动。谢谢大家。
```
